---
description: Next.jsのFast Refreshは新しいホット・リロードの仕組みであり、あなたのReactコンポーネントへの変更について継続的なフィードバックを提供します。
---

# Fast Refresh機能

<details open>
  <summary><b>例</b></summary>
  <ul>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/fast-refresh-demo">Fast Refresh機能のデモ</a></li>
  </ul></details>

Next.jsが提供するFast Refresh機能は、あなたのReactコンポーネントへの変更について継続的なフィードバックを提供します。この機能はNext.jsバージョン**9.4以上**のすべてのアプリケーションでデフォルトで有効です。この機能を有効にすることで、**コンポーネントのステートの喪失なしに**、すべての変更が数秒のうちに画面に反映されます。

## どのように機能するのか

- **Reactコンポーネントのみをエクスポートする**ファイルを編集した場合、Fast Refresh機能は当該ファイルのコードのみを更新し、コンポーネントを再レンダリングします。当該ファイル内のスタイル、レンダリング・ロジック、イベント・ハンドラ、あるいはエフェクトをも含むどんなものでも、変更が可能です。
- Reactコンポーネント*以外のもの*をエクスポートするファイルを編集した場合、Fast Refresh機能は当該ファイルとそのファイルをインポートしている他のファイルのいずれもを再実行します。例えば`Button.js`と`Modal.js`の2つのコンポーネントが`theme.js`をインポートしている場合、`theme.js`に対する変更は2つのコンポーネントの更新も引き起こします。
- 最後に、**Reactコンポーネント・ツリーの外部にあるファイルからインポートされ**ている**ファイルを編集**した場合、Fast Refresh機能は**フォールバックとして全体の再読み込みを行い**ます。あるファイルがReactコンポーネントをレンダリングする傍ら、とある値をエクスポートしており、それが**非Reactコンポーネント**からインポートされていることがあります。例えば、あなたのコンポーネントはとある定数もエクスポートしており、それが非Reactコンポーネントのユーティリティ関数を提供するファイルからインポートされているようなケースです。このようなケースでは、定数を別のファイルに移動し、それをReactコンポーネントと非Reactコンポーネントの2つのファイルから読み込むことを検討すべきです。これによりFast Refreshが機能するようになります。他のケースもしばしば同様の方法で解決できます。

## エラーに対する復元力

### 構文エラー

開発中に構文エラーが起きた場合、修正してから再度ファイルを保存します。するとエラーは自動的に解消するので、あなたがアプリのリロードを行う必要はありません。**コンポーネントのステートは失われません**。

### 実行時エラー

コンポーネントの内部で実行時エラーを引き起こすバグを作り込んでしまった場合、あなたは状況に即したオーバーレイ表示を目にすることになるでしょう。当該エラーを修正すると、アプリのリロードなしにオーバーレイも自動的に消えます。

当該エラーがレンダリング過程で発生したものでない場合、コンポーネントのステートは保たれます。エラーがレンダリング過程で発生したものである場合、Reactは更新されたコードを使用してあなたのアプリを再マウントします。

あなたのアプリに[エラー境界](https://reactjs.org/docs/error-boundaries.html)を設けている場合（これは本番環境において優雅な機能を提供するために良いアイデアです）、レンダリング・エラーの後のファイル編集に伴い再レンダリングが試みられます。このことはつまりエラー境界を用いることでルート・アプリのステートが毎回リセットされてしまうのを防ぐことができるということです。しかしながら、エラー境界を*あまりに*細かい粒度にすべきでないという点は心に留めておくべきです。それらはプロダクション・モードにおいてReactから利用されており、常に明確な意図のもとで設計されるべきものです。

## 制限事項

Fast Refresh機能はあなたが編集しているコンポーネントにおけるローカルのReactステートを維持するよう努力しますが、間違いなくそれができる場合に限ります。ファイルの編集の都度ローカル・ステートのリセットが生じるのにはいくつかの理由があります：

- クラス・コンポーネントについてはローカル・ステートは維持されない（関数コンポーネントとReactHookのステートのみが維持される）。
- あなたの編集しているファイルがReactコンポーネントに加えて*それ以外*のものもエクスポートしている場合。
- 時折あることだが、`HOC（WrappedComponent）`のような高階コンポーネントの呼び出し結果をエクスポートするファイル。呼び出し結果のコンポーネントがクラスである場合、ステートはリセットされる。
-  `export default () => <div />;`のような匿名アロー関数はFast Refresh機能のローカル・コンポーネント・ステートの維持を阻害する。コードベースが大きくなって来たプロジェクトには、私たちの提供する[`name-default-component`というcodemod](/docs/advanced-features/codemods.md#name-default-component)が利用できる。

あなたのコードベースが関数コンポーネントとReactHookに基づくものに移行するにつれて、より多くのケースでステートの維持がされるようになります。

## ヒント

- Fast Refresh機能はデフォルトで関数コンポーネント（およびReactHook）におけるローカル・ステートを維持する。
- 時折ステートを*強いて*リセットしてコンポーネントを再マウントさせたいことがあるかもしれない。例えば、マウント時に発生するアニメーションの微調整をしているような場合そのほうが好都合である。これを行うには、編集中のファイルのどこでもいいので`// @refresh reset`を追記すればよい。このディレクティブは当該ファイル内でのみ有効で、当該ファイルで定義されているコンポーネントを編集の都度再マウントするようFast Refreshに対して仕向ける。
- 開発のあいだは`console.log`や`debugger;`を編集するコンポーネント内で利用することができる。

## Fast Refresh機能とReactHook

Fast Refresh機能は、可能な時はいつでも、編集中のコンポーネントの状態を維持しようとします。とくに`useState`と`useRef`は、それらの引数やReactHookの呼び出し順序を変更したりしない限り、元々の値を維持します。

依存性を伴うReactHook──`useEffect`、`useMemo`、そして`useCallback`のような──は、Fast Refresh中に*必ず*更新されます。それらの依存性のリストはFast Refreshが動いている間は無視されます。

例えば、`useMemo(() => x * 2, [x])`を`useMemo(() => x * 10, [x])`へと変更する時、このHookは`x`（依存性）が変更されていなくても再実行されます。もしReactがこれを行わないと、あなたが編集した内容は画面に反映されなくなってしまいます！

時折、この挙動が想定外の結果を引き起こします。例えば、`useEffect`の依存性の配列が空であっても、それはFast Refresh中に再実行されてしまいます。

しかしながら、`useEffect`の偶発的な再実行にも耐えるコードを書くことは、Fast Refresh機能が無効になってしまうとしてもよいプラクティスです。将来的に新しい依存性を導入する際の助けとなり、[React Strict Mode](/docs/api-reference/next.config.js/react-strict-mode.md)により強制させることができます。この機能を有効化することを強くおすすめします。
